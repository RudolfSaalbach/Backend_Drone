// ./scripts/detectLoginWall.js
function detectLoginWall() {
    const indicators = [
        'input[type="password"]',
        'input[name*="password"]',
        'form[action*="login"]',
        'form[action*="signin"]',
        'button:contains("Sign in")',
        'button:contains("Log in")'
    ];
    
    for (const selector of indicators) {
        const element = document.querySelector(selector);
        if (element && element.offsetParent !== null) {
            return {
                detected: true,
                reason: 'login_wall',
                evidence: selector,
                element: element
            };
        }
    }
    
    return { detected: false };
}

// ./scripts/detectCaptcha.js  
function detectCaptcha() {
    const indicators = [
        'iframe[src*="recaptcha"]',
        'iframe[src*="captcha"]',
        'iframe[src*="hcaptcha"]',
        'div[class*="captcha"]',
        'div[id*="captcha"]',
        'img[alt*="captcha"]'
    ];
    
    for (const selector of indicators) {
        const element = document.querySelector(selector);
        if (element && element.offsetParent !== null) {
            return {
                detected: true,
                reason: 'captcha',
                evidence: selector,
                element: element
            };
        }
    }
    
    return { detected: false };
}

// ./scripts/detectConsent.js
function detectConsent() {
    const indicators = [
        'div[class*="consent"]:visible',
        'div[class*="cookie"]:visible',
        'div[class*="gdpr"]:visible',
        'div[class*="privacy"]:visible',
        'button:contains("Accept"):visible',
        'button:contains("I agree"):visible'
    ];
    
    for (const selector of indicators) {
        try {
            const elements = document.querySelectorAll(selector.replace(':visible', ''));
            for (const element of elements) {
                if (element.offsetParent !== null && 
                    element.getBoundingClientRect().height > 50) {
                    return {
                        detected: true,
                        reason: 'consent_wall',
                        evidence: selector,
                        element: element
                    };
                }
            }
        } catch (e) {
            // Ignore selector errors
        }
    }
    
    return { detected: false };
}

// ./scripts/hlType.js
async function hlType(selector, text, profile) {
    const element = document.querySelector(selector);
    if (!element) throw new Error('Element not found: ' + selector);
    
    element.focus();
    element.click();
    
    // Clear if needed
    if (profile.clearFirst) {
        element.value = '';
        element.innerText = '';
        element.dispatchEvent(new Event('input', {bubbles: true}));
    }
    
    // Type with human-like delays
    let totalDelay = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        
        // Add character
        if (element.value !== undefined) {
            element.value += char;
        } else {
            element.innerText += char;
        }
        
        // Dispatch events
        element.dispatchEvent(new KeyboardEvent('keydown', { key: char }));
        element.dispatchEvent(new Event('input', { bubbles: true }));
        element.dispatchEvent(new KeyboardEvent('keyup', { key: char }));
        
        // Calculate delay with variance
        const delay = profile.charDelayMs + 
            (Math.random() - 0.5) * 2 * profile.varianceMs;
        
        await new Promise(r => setTimeout(r, Math.max(10, delay)));
        totalDelay += delay;
        
        // Check caps
        if (totalDelay > profile.maxDelayMs) break;
    }
    
    return { typed: text.length, totalDelayMs: totalDelay };
}

// ./scripts/hlClick.js
async function hlClick(selector, profile) {
    const element = document.querySelector(selector);
    if (!element) throw new Error('Element not found: ' + selector);
    
    // Scroll into view
    element.scrollIntoView({behavior: 'smooth', block: 'center'});
    await new Promise(r => setTimeout(r, profile.preMoveDelayMs));
    
    // Get position
    const rect = element.getBoundingClientRect();
    const x = rect.left + rect.width / 2;
    const y = rect.top + rect.height / 2;
    
    // Simulate mouse events
    const mouseEventInit = {
        view: window,
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y
    };
    
    element.dispatchEvent(new MouseEvent('mouseenter', mouseEventInit));
    await new Promise(r => setTimeout(r, profile.hoverMs));
    
    element.dispatchEvent(new MouseEvent('mouseover', mouseEventInit));
    await new Promise(r => setTimeout(r, profile.hoverMs));
    
    element.dispatchEvent(new MouseEvent('mousedown', mouseEventInit));
    await new Promise(r => setTimeout(r, 50));
    
    element.dispatchEvent(new MouseEvent('mouseup', mouseEventInit));
    element.dispatchEvent(new MouseEvent('click', mouseEventInit));
    
    return { clicked: true, totalDelayMs: profile.preMoveDelayMs + profile.hoverMs * 2 + 50 };
}

// ./scripts/hlScroll.js
async function hlScroll(profile) {
    const direction = profile.directionDefault || 'down';
    const chunkPx = profile.chunkPx || 280;
    const chunks = profile.chunks || 3;
    const baseDelay = profile.delayMs || 180;
    const variance = profile.varianceMs || 60;
    
    let totalScrolled = 0;
    let totalDelay = 0;
    
    for (let i = 0; i < chunks; i++) {
        const scrollAmount = direction === 'up' ? -chunkPx : chunkPx;
        
        window.scrollBy({
            top: scrollAmount,
            behavior: 'smooth'
        });
        
        totalScrolled += Math.abs(scrollAmount);
        
        // Variable delay
        const delay = baseDelay + (Math.random() - 0.5) * 2 * variance;
        await new Promise(r => setTimeout(r, Math.max(50, delay)));
        totalDelay += delay;
    }
    
    return { scrolledPx: totalScrolled, chunks: chunks, totalDelayMs: totalDelay };
}

// ./scripts/hlMouseMove.js
async function hlMouseMove(profile) {
    if (!profile.enable) return { moved: false };
    
    const steps = 5;
    const hoverMs = profile.hoverMs || 120;
    
    for (let i = 0; i < steps; i++) {
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight;
        
        document.dispatchEvent(new MouseEvent('mousemove', {
            clientX: x,
            clientY: y,
            bubbles: true
        }));
        
        await new Promise(r => setTimeout(r, hoverMs / steps));
    }
    
    return { moved: true, steps: steps, totalDelayMs: hoverMs };
}