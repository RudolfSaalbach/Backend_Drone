using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Aura.Orchestrator.Scheduling
{
    /// <summary>
    /// Scheduler mit bounded Queues gemäß §5 der Spezifikation
    /// </summary>
    public class TaskScheduler : BackgroundService
    {
        private readonly ILogger<TaskScheduler> _logger;
        private readonly OrchestratorConfig _config;
        private readonly IDroneRegistry _droneRegistry;
        private readonly IPersonaLibrary _personaLibrary;
        private readonly IDomainLimiter _domainLimiter;
        private readonly IHubContext<DroneHub> _hubContext;

        // Global Ready Queue (§5.2)
        private readonly Channel<ScheduledTask> _globalReadyQueue;
        
        // Per-Drone Queues (§5.2)
        private readonly ConcurrentDictionary<string, Channel<ScheduledTask>> _perDroneQueues;
        
        // Pacing Tokens für In-Flight-Regel (§2.4)
        private readonly ConcurrentDictionary<string, SemaphoreSlim> _pacingTokens;
        
        // Metrics
        private readonly IMetricsCollector _metrics;

        public TaskScheduler(
            ILogger<TaskScheduler> logger,
            IOptions<OrchestratorConfig> config,
            IDroneRegistry droneRegistry,
            IPersonaLibrary personaLibrary,
            IDomainLimiter domainLimiter,
            IHubContext<DroneHub> hubContext,
            IMetricsCollector metrics)
        {
            _logger = logger;
            _config = config.Value;
            _droneRegistry = droneRegistry;
            _personaLibrary = personaLibrary;
            _domainLimiter = domainLimiter;
            _hubContext = hubContext;
            _metrics = metrics;

            // Global Ready Queue mit Capacity 1000, DropOldest
            var globalOptions = new BoundedChannelOptions(_config.Scheduling.ReadyQueue.Capacity)
            {
                FullMode = BoundedChannelFullMode.DropOldest,
                SingleReader = false,
                SingleWriter = false
            };
            _globalReadyQueue = Channel.CreateBounded<ScheduledTask>(globalOptions);

            _perDroneQueues = new ConcurrentDictionary<string, Channel<ScheduledTask>>();
            _pacingTokens = new ConcurrentDictionary<string, SemaphoreSlim>();
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Task Scheduler starting");

            // Starte parallele Verarbeitung
            var tasks = new List<Task>
            {
                ProcessGlobalQueue(stoppingToken),
                ProcessPerDroneQueues(stoppingToken),
                MonitorQueueMetrics(stoppingToken)
            };

            await Task.WhenAll(tasks);
        }

        #region Queue Processing

        /// <summary>
        /// Verarbeitet Global Ready Queue und verteilt auf Per-Drone Queues
        /// </summary>
        private async Task ProcessGlobalQueue(CancellationToken cancellationToken)
        {
            await foreach (var task in _globalReadyQueue.Reader.ReadAllAsync(cancellationToken))
            {
                try
                {
                    // Finde passende Drone(s) für Task
                    var eligibleDrones = await FindEligibleDrones(task);
                    
                    if (!eligibleDrones.Any())
                    {
                        _logger.LogWarning($"No eligible drone found for task {task.CommandId}");
                        await HandleNoEligibleDrone(task);
                        continue;
                    }

                    // Wähle beste Drone nach Weighted Round Robin (§5.3)
                    var selectedDrone = SelectDroneByWeightedRoundRobin(eligibleDrones, task);
                    
                    if (selectedDrone != null)
                    {
                        // Enqueue in Per-Drone Queue
                        if (await EnqueueToPerDroneQueue(selectedDrone.DroneId, task))
                        {
                            _logger.LogDebug($"Task {task.CommandId} queued for drone {selectedDrone.DroneId}");
                            _metrics.RecordTaskQueued(task.CommandId, selectedDrone.DroneId);
                        }
                        else
                        {
                            _logger.LogWarning($"Failed to queue task {task.CommandId} for drone {selectedDrone.DroneId}");
                            await HandleQueueFullError(task);
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, $"Error processing task {task.CommandId} from global queue");
                }
            }
        }

        /// <summary>
        /// Verarbeitet Per-Drone Queues und dispatched zu Drones
        /// </summary>
        private async Task ProcessPerDroneQueues(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                foreach (var kvp in _perDroneQueues)
                {
                    var droneId = kvp.Key;
                    var queue = kvp.Value;

                    // Prüfe ob Drone verfügbar ist (Pacing Token)
                    if (!await IsDroneAvailable(droneId))
                        continue;

                    // Versuche Task aus Queue zu holen
                    if (queue.Reader.TryRead(out var task))
                    {
                        // Dispatch Task zu Drone
                        await DispatchTaskToDrone(droneId, task);
                    }
                }

                await Task.Delay(100, cancellationToken); // Kurze Pause zwischen Durchläufen
            }
        }

        #endregion

        #region Task Enqueuing

        /// <summary>
        /// Fügt Task zur Global Ready Queue hinzu
        /// </summary>
        public async Task<bool> EnqueueTask(ScheduledTask task)
        {
            try
            {
                // Validiere Task
                if (!await ValidateTask(task))
                {
                    _logger.LogWarning($"Task {task.CommandId} failed validation");
                    return false;
                }

                // Prüfe Domain Limits (§6)
                if (!await _domainLimiter.CheckGlobalLimits(task.Domain))
                {
                    _logger.LogWarning($"Task {task.CommandId} blocked by domain limiter for {task.Domain}");
                    return false;
                }

                // Enqueue mit Priorität
                task.EnqueuedAt = DateTime.UtcNow;
                
                if (_globalReadyQueue.Writer.TryWrite(task))
                {
                    _metrics.UpdateQueueLength("global", _globalReadyQueue.Reader.Count);
                    _logger.LogDebug($"Task {task.CommandId} added to global ready queue");
                    return true;
                }
                else
                {
                    _logger.LogWarning($"Global ready queue full, dropping oldest for task {task.CommandId}");
                    // DropOldest ist automatisch durch BoundedChannelFullMode.DropOldest
                    return _globalReadyQueue.Writer.TryWrite(task);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to enqueue task {task.CommandId}");
                return false;
            }
        }

        /// <summary>
        /// Fügt Task zur Per-Drone Queue hinzu
        /// </summary>
        private async Task<bool> EnqueueToPerDroneQueue(string droneId, ScheduledTask task)
        {
            try
            {
                // Erstelle Queue falls nicht vorhanden
                var queue = _perDroneQueues.GetOrAdd(droneId, _ =>
                {
                    var options = new BoundedChannelOptions(_config.Scheduling.PerDroneQueue.Capacity)
                    {
                        FullMode = BoundedChannelFullMode.DropOldest,
                        SingleReader = true,
                        SingleWriter = false
                    };
                    return Channel.CreateBounded<ScheduledTask>(options);
                });

                if (queue.Writer.TryWrite(task))
                {
                    _metrics.UpdateQueueLength($"drone_{droneId}", queue.Reader.Count);
                    return true;
                }
                else
                {
                    _logger.LogWarning($"Per-drone queue for {droneId} full, dropping oldest");
                    return queue.Writer.TryWrite(task);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to enqueue task to drone {droneId}");
                return false;
            }
        }

        #endregion

        #region Drone Selection

        /// <summary>
        /// Findet eligible Drones basierend auf Persona und Capabilities
        /// </summary>
        private async Task<List<DroneInfo>> FindEligibleDrones(ScheduledTask task)
        {
            var allDrones = await _droneRegistry.GetActiveDrones();
            var eligibleDrones = new List<DroneInfo>();

            foreach (var drone in allDrones)
            {
                // Prüfe Capability Match (§3.2)
                if (!MatchesCapabilities(drone, task.RequiredCapabilities))
                    continue;

                // Prüfe Domain Limits für diese Drone
                if (!await _domainLimiter.CheckDroneLimits(drone.DroneId, task.Domain))
                    continue;

                eligibleDrones.Add(drone);
            }

            return eligibleDrones;
        }

        /// <summary>
        /// Wählt Drone nach Weighted Round Robin mit Fairness (§5.3)
        /// </summary>
        private DroneInfo SelectDroneByWeightedRoundRobin(List<DroneInfo> drones, ScheduledTask task)
        {
            if (!drones.Any())
                return null;

            // Sortiere nach Priorität und Fairness
            var sortedDrones = drones
                .OrderBy(d => d.CurrentLoad) // Niedrigste Last zuerst
                .ThenBy(d => d.LastTaskAssignedAt) // Längste Leerlaufzeit
                .ThenByDescending(d => CalculateDroneScore(d, task)) // Bester Match
                .ToList();

            return sortedDrones.FirstOrDefault();
        }

        private double CalculateDroneScore(DroneInfo drone, ScheduledTask task)
        {
            double score = 1.0;

            // Bonus für exakte Capability Matches
            var matchCount = drone.StaticCapabilities.Intersect(task.RequiredCapabilities).Count();
            score += matchCount * 0.1;

            // Penalty für hohe Last
            score -= drone.CurrentLoad * 0.2;

            // Bonus für längere Idle-Zeit
            var idleMinutes = (DateTime.UtcNow - drone.LastTaskAssignedAt).TotalMinutes;
            score += Math.Min(idleMinutes * 0.01, 0.5);

            return score;
        }

        private bool MatchesCapabilities(DroneInfo drone, List<string> requiredCapabilities)
        {
            if (requiredCapabilities == null || !requiredCapabilities.Any())
                return true;

            return requiredCapabilities.All(cap => drone.StaticCapabilities.Contains(cap));
        }

        #endregion

        #region Task Dispatching

        /// <summary>
        /// Dispatched Task an Drone mit Pacing Token
        /// </summary>
        private async Task DispatchTaskToDrone(string droneId, ScheduledTask task)
        {
            try
            {
                // Acquire Pacing Token (§2.4)
                var pacingToken = _pacingTokens.GetOrAdd(droneId, _ => new SemaphoreSlim(1, 1));
                
                if (!await pacingToken.WaitAsync(0)) // Non-blocking check
                {
                    _logger.LogDebug($"Drone {droneId} has in-flight task, skipping dispatch");
                    return;
                }

                try
                {
                    // Lade Persona
                    var persona = await _personaLibrary.LoadPersona(task.PersonaId);
                    if (persona == null)
                    {
                        _logger.LogError($"Persona {task.PersonaId} not found for task {task.CommandId}");
                        pacingToken.Release();
                        return;
                    }

                    // Erstelle Command Payload mit eingebetteter Persona (§3.2)
                    var command = new CommandPayload
                    {
                        CommandId = task.CommandId,
                        Type = task.Type,
                        Parameters = task.Parameters,
                        Persona = persona,
                        Session = task.Session,
                        TimeoutSec = task.TimeoutSec
                    };

                    // Sende Command an Drone
                    await _hubContext.SendCommandToDrone(droneId, command);
                    
                    // Update Drone Status
                    await _droneRegistry.UpdateDroneStatus(droneId, new StatusPayload 
                    { 
                        Status = "busy",
                        CurrentCommand = task.CommandId 
                    });

                    // Start Ack Timeout Timer
                    _ = Task.Run(async () => await MonitorAckTimeout(droneId, task.CommandId, pacingToken));

                    _logger.LogInformation($"Dispatched task {task.CommandId} to drone {droneId}");
                    _metrics.RecordTaskDispatched(task.CommandId, droneId);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, $"Failed to dispatch task {task.CommandId} to drone {droneId}");
                    pacingToken.Release();
                    
                    // Re-queue task
                    await EnqueueTask(task);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error in dispatch process for drone {droneId}");
            }
        }

        /// <summary>
        /// Überwacht Ack Timeout und released Token bei Timeout
        /// </summary>
        private async Task MonitorAckTimeout(string droneId, string commandId, SemaphoreSlim pacingToken)
        {
            await Task.Delay(TimeSpan.FromSeconds(_config.Scheduling.AckTimeoutSec));

            // Prüfe ob Ack empfangen wurde
            if (!await IsCommandAcknowledged(commandId))
            {
                _logger.LogWarning($"Ack timeout for command {commandId} on drone {droneId}");
                pacingToken.Release();
                
                // Mark drone as potentially problematic
                await _droneRegistry.IncrementDroneErrorCount(droneId);
            }
        }

        #endregion

        #region Helper Methods

        private async Task<bool> IsDroneAvailable(string droneId)
        {
            var drone = await _droneRegistry.GetDrone(droneId);
            if (drone == null || drone.Status != DroneStatus.Idle)
                return false;

            // Check if drone has pacing token available
            if (_pacingTokens.TryGetValue(droneId, out var token))
            {
                return token.CurrentCount > 0;
            }

            return true;
        }

        private async Task<bool> ValidateTask(ScheduledTask task)
        {
            if (string.IsNullOrEmpty(task.CommandId))
                return false;
            
            if (string.IsNullOrEmpty(task.PersonaId))
                return false;
                
            if (string.IsNullOrEmpty(task.Type))
                return false;
                
            return true;
        }
        
        private async Task<bool> IsCommandAcknowledged(string commandId)
        {
            // Implementation would check command status in database
            return await Task.FromResult(true);
        }
        
        private async Task HandleNoEligibleDrone(ScheduledTask task)
        {
            _logger.LogWarning($"No eligible drone for task {task.CommandId}, will retry");
            // Re-enqueue with delay
            await Task.Delay(5000);
            await EnqueueTask(task);
        }
        
        private async Task HandleQueueFullError(ScheduledTask task)
        {
            _logger.LogError($"Queue full error for task {task.CommandId}");
            _metrics.RecordTaskDropped(task.CommandId);
        }

        private async Task MonitorQueueMetrics(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    _metrics.UpdateQueueLength("global", _globalReadyQueue.Reader.Count);
                    
                    foreach (var kvp in _perDroneQueues)
                    {
                        _metrics.UpdateQueueLength($"drone_{kvp.Key}", kvp.Value.Reader.Count);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error monitoring queue metrics");
                }
                
                await Task.Delay(5000, cancellationToken);
            }
        }

        #endregion
    }

    /// <summary>
    /// Domain Limiter für Anti-Ban Schutz gemäß §6
    /// </summary>
    public class DomainLimiter : IDomainLimiter
    {
        private readonly ILogger<DomainLimiter> _logger;
        private readonly OrchestratorConfig _config;
        private readonly ConcurrentDictionary<string, DomainLimitState> _domainStates;
        private readonly ConcurrentDictionary<string, ConcurrentDictionary<string, DroneDomainState>> _droneDomainStates;

        public DomainLimiter(ILogger<DomainLimiter> logger, IOptions<OrchestratorConfig> config)
        {
            _logger = logger;
            _config = config.Value;
            _domainStates = new ConcurrentDictionary<string, DomainLimitState>();
            _droneDomainStates = new ConcurrentDictionary<string, ConcurrentDictionary<string, DroneDomainState>>();
        }

        public async Task<bool> CheckGlobalLimits(string domain)
        {
            if (string.IsNullOrEmpty(domain))
                return true;

            var state = _domainStates.GetOrAdd(domain, _ => new DomainLimitState());
            
            // Check MaxConcurrentSessionsPerDomain (§6.1)
            if (state.CurrentSessions >= _config.Limits.MaxConcurrentSessionsPerDomain)
            {
                _logger.LogWarning($"Domain {domain} at max concurrent sessions limit");
                return false;
            }

            return true;
        }

        public async Task<bool> CheckDroneLimits(string droneId, string domain)
        {
            if (string.IsNullOrEmpty(domain))
                return true;

            var droneStates = _droneDomainStates.GetOrAdd(droneId, _ => new ConcurrentDictionary<string, DroneDomainState>());
            var state = droneStates.GetOrAdd(domain, _ => new DroneDomainState());

            var now = DateTime.UtcNow;
            
            // Check QPS (§6.1)
            state.CleanOldRequests(now);
            
            if (state.GetCurrentQps(now) >= _config.Limits.PerDomain.QpsPerDrone)
            {
                _logger.LogDebug($"Drone {droneId} exceeds QPS limit for domain {domain}");
                return false;
            }

            // Check Concurrency (§6.1)
            if (state.CurrentConcurrency >= _config.Limits.PerDomain.ConcurrencyPerDrone)
            {
                _logger.LogDebug($"Drone {droneId} at concurrency limit for domain {domain}");
                return false;
            }

            // Check Cooldown
            if (state.InCooldown(now))
            {
                _logger.LogDebug($"Drone {droneId} in cooldown for domain {domain}");
                return false;
            }

            return true;
        }

        public async Task RecordDomainAccess(string droneId, string domain)
        {
            var globalState = _domainStates.GetOrAdd(domain, _ => new DomainLimitState());
            globalState.CurrentSessions++;

            var droneStates = _droneDomainStates.GetOrAdd(droneId, _ => new ConcurrentDictionary<string, DroneDomainState>());
            var state = droneStates.GetOrAdd(domain, _ => new DroneDomainState());
            
            state.RecordRequest(DateTime.UtcNow);
            state.CurrentConcurrency++;
        }

        public async Task ReleaseDomainAccess(string droneId, string domain)
        {
            if (_domainStates.TryGetValue(domain, out var globalState))
            {
                globalState.CurrentSessions = Math.Max(0, globalState.CurrentSessions - 1);
            }

            if (_droneDomainStates.TryGetValue(droneId, out var droneStates))
            {
                if (droneStates.TryGetValue(domain, out var state))
                {
                    state.CurrentConcurrency = Math.Max(0, state.CurrentConcurrency - 1);
                }
            }
        }
    }

    #region Supporting Classes

    public class ScheduledTask
    {
        public string CommandId { get; set; }
        public string Type { get; set; }
        public string PersonaId { get; set; }
        public List<string> RequiredCapabilities { get; set; }
        public string Domain { get; set; }
        public JObject Parameters { get; set; }
        public SessionInfo Session { get; set; }
        public int TimeoutSec { get; set; }
        public TaskPriority Priority { get; set; }
        public DateTime EnqueuedAt { get; set; }
        public string NodeId { get; set; }
        public string ProcessId { get; set; }
    }

    public class DomainLimitState
    {
        public int CurrentSessions { get; set; }
        public DateTime LastAccess { get; set; }
    }

    public class DroneDomainState
    {
        private readonly Queue<DateTime> _requestTimes = new Queue<DateTime>();
        private DateTime _cooldownUntil = DateTime.MinValue;
        
        public int CurrentConcurrency { get; set; }
        public int BurstCount { get; set; }

        public void RecordRequest(DateTime timestamp)
        {
            _requestTimes.Enqueue(timestamp);
            BurstCount++;
            
            // Check if burst limit exceeded
            if (BurstCount >= 3) // Burst = 3 from config
            {
                _cooldownUntil = timestamp.AddSeconds(30); // CooldownSec = 30
                BurstCount = 0;
            }
        }

        public void CleanOldRequests(DateTime now)
        {
            // Remove requests older than 1 second for QPS calculation
            while (_requestTimes.Count > 0 && (now - _requestTimes.Peek()).TotalSeconds > 1)
            {
                _requestTimes.Dequeue();
            }
        }

        public double GetCurrentQps(DateTime now)
        {
            CleanOldRequests(now);
            return _requestTimes.Count;
        }

        public bool InCooldown(DateTime now)
        {
            return now < _cooldownUntil;
        }
    }

    public enum TaskPriority
    {
        Low = 0,
        Normal = 1,
        High = 2
    }

    public enum DroneStatus
    {
        Idle,
        Busy,
        Disconnected,
        Error
    }

    public class DroneInfo
    {
        public string DroneId { get; set; }
        public string ConnectionId { get; set; }
        public string Version { get; set; }
        public List<string> StaticCapabilities { get; set; }
        public List<string> Modules { get; set; }
        public LimitsSupport LimitsSupported { get; set; }
        public DateTime RegisteredAt { get; set; }
        public DateTime LastHeartbeat { get; set; }
        public DateTime LastTaskAssignedAt { get; set; }
        public DroneStatus Status { get; set; }
        public double CurrentLoad { get; set; }
        public int ErrorCount { get; set; }
    }

    public class CommandPayload
    {
        [JsonProperty("commandId")]
        public string CommandId { get; set; }
        
        [JsonProperty("type")]
        public string Type { get; set; }
        
        [JsonProperty("parameters")]
        public JObject Parameters { get; set; }
        
        [JsonProperty("persona")]
        public PersonaData Persona { get; set; }
        
        [JsonProperty("session")]
        public SessionInfo Session { get; set; }
        
        [JsonProperty("timeoutSec")]
        public int TimeoutSec { get; set; }
    }

    public class QueryPayload
    {
        [JsonProperty("queryId")]
        public string QueryId { get; set; }
        
        [JsonProperty("type")]
        public string Type { get; set; }
        
        [JsonProperty("parameters")]
        public JObject Parameters { get; set; }
    }

    public class SessionInfo
    {
        [JsonProperty("lease_id")]
        public string LeaseId { get; set; }
        
        [JsonProperty("site")]
        public string Site { get; set; }
        
        [JsonProperty("identity")]
        public string Identity { get; set; }
    }

    #endregion
}